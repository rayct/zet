# Large Language Models and The End of Programming

CS50 Tech Talk with Dr. Matt Welsh


01:23 🚀 The field of computer science is undergoing a major transformation where AI models like GPT-3 are being used to write code, marking a significant shift in programming.

06:54 💻 Natural language is becoming a key tool in programming, allowing developers to instruct AI models to generate code without the need for traditional programming languages.

14:47 📈 AI technology, like GPT-3, has the potential to significantly reduce the cost of software development, making it more efficient and cost-effective.

20:52 🤖 The rise of AI in programming will likely change the roles of software engineers, with a shift towards product managers instructing AI models and AI-generated code.

23:46 👁️ Code review practices will evolve to incorporate AI-generated code, requiring a different kind of review process to ensure code quality and functionality.

24:41 🤖 Code maintainability may become less essential with AI-generated code, as long as it works as intended.

25:58 📊 The rapid advancement of AI models like ChatGPT has transformed the computer science field and its societal expectations.

29:04 🌐 Programming is evolving, with AI assisting humans in generating code, and the future may involve direct interaction with AI models instead of traditional programming.

33:44 💬 The concept of a "natural language computer" is emerging, where AI models process natural language commands and perform tasks autonomously.

45:52 💡 The model itself becomes the computer, representing a future where AI empowers people without formal computer science training to harness its capabilities.

49:15 🤖 AI-generated tests are becoming more prevalent, but there's uncertainty about the role of humans in the testing process.

51:07 🧩 The future of AI models relies on the increased availability of transistors and data, which may require custom hardware solutions.

52:06 🤔 Formal reasoning about the capabilities of AI models is a significant challenge, and we may need to shift towards more sociological approaches.

54:23 🤖 Exploring whether one AI model can understand and explain another model is an intriguing idea, but its feasibility remains uncertain.

59:30 🧠 While AI may make software engineers more productive, certain human aspects, like ethics, may remain essential in software development.

---

**FINAL THOUGHTS**

* Unfortunately a lot of Hokus Pokus scare mongery. First CS is not about 'giving a computer instructions to complete a task'. That is one 1st year CS course. I have worked in Systems Architecture and Software Engineering for 6 years in (Japan, Europe and Canada) and I can tell you LLMs/AI  are not replacing anyone. Anybody claiming that, has either never designed production systems before or is trying to sell something. Nobody employs Software Engineers to 'write code blocks or write code for IO operations', Software Engineers earn a lot because they 'Build' and 'Architect' scalable production systems. Systems Design is a logical process that requires a lot of deep critical thinking and requires human intelligence (And No AI are not achieving nor will they ever achieve human intelligence). Decisions can never be automated or 'learnt'. The problem is that everyone thinks Software Engineering is 'programming'. I installed Copilot and uninstalled it 2 days later. I really can't see how Copilot will help me let alone replace me. Here is a tip for all Engineers, if you find the code from Copilot useful or that it makes you more 'productive', then you are probably writing really bad code and your codebase is probably a mess (Maybe why you will loos your job?). That said, I agree, Copilot is extremely good for Boilerplate codes and automating some CI/CD stuff. But the negatives far outweighs the positives.


* The example with Conways game of life does no justice to the 50 years of programming language research he refers to. Also, Rust was designed to overcome the memory safety problems that plagued C and C++; it is a programming language that emphasizes performance and memory-safety. Programming languages like Fortran and C were designed the way they are for a very specific reason: They target Von Neumann architectures, and fall under the category of "Von Neumann programming languages". The goal of these languages is to provide humans with a language to specify the behavior of a Von Neumann machine, so of course the language itself will have constructs that model the von Neumann architecture. Programming languages like Rust or C do exactly what they were designed to do, they are not "attempts" to improve only code readability for Conways game of life when compared to Fortran.

---

Documentation By: **Raymond C. TURNER**

**Revision:** Saturday 9th December 2023

